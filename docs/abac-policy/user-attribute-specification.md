# ユーザー属性設定方法仕様書

## 概要

ABAC（属性ベースアクセス制御）におけるユーザー属性の設定方法について、現在の理解に基づく仕様を整理した文書です。

## 基本概念

### ユーザー属性とは

ユーザー属性は、アクセス制御の判断基準となるユーザーの特性を表す情報です。

#### 主要なユーザー属性
- **部署**: ユーザーが所属する部署
- **職位**: ユーザーの職位・役職
- **システムレベル**: ユーザーのシステムアクセスレベル
- **役割**: ユーザーが持つ役割・権限
- **ユーザーID**: ユーザーの識別子
- **作成者**: データの作成者

### 属性の設定パターン

#### 配列形式での設定
```
単一値: 部署 = ["営業部"]
→ ユーザーが営業部に所属している場合のみ該当

複数値: 部署 = ["営業部", "マーケティング部", "企画部"]
→ ユーザーが営業部、マーケティング部、企画部のいずれかに所属している場合に該当
```

**統一性**: すべての条件が配列形式で統一される

## 演算子の仕様

### フィールド別演算子設定

#### フィールドごとの演算子制限
各フィールド（属性）ごとに使用可能な演算子を制限し、適切な条件設定を可能にします。

```php
'field_operators' => [
    'user.department_id' => ['in' => '含む'],
    'user.position_id' => ['in' => '含む', 'gte' => '以上', 'lte' => '以下'],
    'user.system_level' => ['in' => '含む', 'gte' => '以上', 'lte' => '以下'],
    'user.roles' => ['in' => '含む'],
    'user.id' => ['in' => '含む'],
    'data.created_by' => ['in' => '含む']
]
```

#### フィールド別の演算子説明

**部署 (user.department_id)**
- 使用可能演算子: 含む (in) のみ
- 理由: 部署は階層的な比較が不適切

**職位 (user.position_id)**
- 使用可能演算子: 含む (in), 以上 (gte), 以下 (lte)
- 理由: 職位は階層的な順序を持つ（社員 < 担当 < 課長 < 部長）
- 比較方法: 職位テーブルの優先順位（priority）フィールドを使用

**システムレベル (user.system_level)**
- 使用可能演算子: 含む (in), 以上 (gte), 以下 (lte)
- 理由: システムレベルは数値的な階層を持つ（1, 2, 3, 4, 5）
- 比較方法: システムレベルテーブルの優先順位（priority）フィールドを使用

**役割 (user.roles)**
- 使用可能演算子: 含む (in) のみ
- 理由: 役割は階層的な比較が不適切

**ユーザーID (user.id)**
- 使用可能演算子: 含む (in) のみ
- 理由: ユーザーIDは階層的な比較が不適切

**作成者 (data.created_by)**
- 使用可能演算子: 含む (in) のみ
- 理由: 作成者は階層的な比較が不適切

### 基本演算子

#### 1. 含む (in)
**用途**: 配列形式での条件設定

**動作**: 配列形式での条件設定

**意味**: 設定している部署に対してアクセス許可、設定していない部署に対してアクセス拒否

**例**:
```
条件: 部署 含む ["営業部"]
→ 営業部に所属するユーザーにアクセス許可
→ 営業部以外の部署に所属するユーザーはアクセス拒否

条件: 部署 含む ["営業部", "マーケティング部", "企画部"]
→ 営業部、マーケティング部、企画部のいずれかに所属するユーザーにアクセス許可
→ 経理部、総務部など、設定していない部署に所属するユーザーはアクセス拒否
```

#### 2. 以上 (gte)
**用途**: 数値やレベルの範囲指定（下限）

**適用フィールド**: 職位、システムレベル

**職位での使用例**:
```
条件: 職位 >= 課長
→ 課長以上の職位のユーザーが該当
→ 職位テーブルの優先順位（priority）フィールドで比較
```

**システムレベルでの使用例**:
```
条件: システムレベル >= 3
→ システムレベル3以上のユーザーが該当
→ システムレベルテーブルの優先順位（priority）フィールドで比較
```

#### 3. 以下 (lte)
**用途**: 数値やレベルの範囲指定（上限）

**適用フィールド**: 職位、システムレベル

**職位での使用例**:
```
条件: 職位 <= 担当
→ 担当以下の職位のユーザーが該当
→ 職位テーブルの優先順位（priority）フィールドで比較
```

**システムレベルでの使用例**:
```
条件: システムレベル <= 5
→ システムレベル5以下のユーザーが該当
→ システムレベルテーブルの優先順位（priority）フィールドで比較
```

### 削除された演算子

#### 含む (in)
**削除理由**: 「等しい」演算子で代替可能

**従来の動作**:
```
条件: 部署 含む [営業部, マーケティング部, 企画部]
→ 部署が営業部、マーケティング部、企画部のいずれかに含まれる
```

**代替方法**:
```
条件: 部署 = ["営業部", "マーケティング部", "企画部"]
→ 同じ動作を実現（より簡潔）
```

#### いずれかを含む (hasAny)
**削除理由**: 「等しい」演算子で代替可能

**従来の動作**:
```
条件: 役割 いずれかを含む [営業マネージャー, 営業担当, 営業アシスタント]
→ 役割に営業マネージャー、営業担当、営業アシスタントのいずれかが含まれる
```

**代替方法**:
```
条件: 役割 = ["営業マネージャー", "営業担当", "営業アシスタント"]
→ 同じ動作を実現（より簡潔）
```

## 条件設定の方法

### 条件の設定

#### 単一値の設定
```
フィールド: 部署
演算子: 含む
値: ["営業部"]
```

#### 複数値の設定
```
フィールド: 部署
演算子: 含む
値: ["営業部", "マーケティング部", "企画部"]
```

### 複数条件の設定

#### OR論理結合
```
論理結合: OR
条件1: 部署 = 営業部
条件2: 部署 = マーケティング部
条件3: 部署 = 企画部
```

#### AND論理結合
```
論理結合: AND
条件1: 部署 = 営業部
条件2: システムレベル >= 3
条件3: 役割 = 営業マネージャー
```

### 複雑な条件の設定

#### ネストした条件
```
論理結合: AND
条件1: 部署 = 営業部
条件2: 
  論理結合: OR
  条件2-1: 役割 = 営業マネージャー
  条件2-2: 役割 = 営業担当
条件3: システムレベル >= 2
```

## 実務での使用例

### ケース1: 営業データの削除権限
```
条件: 役割 含む ["営業マネージャー"]
→ 営業マネージャーのみ削除可能
→ 営業マネージャー以外の役割のユーザーは削除不可
```

### ケース2: 営業関連部署のアクセス制御
```
条件: 部署 含む ["営業部", "マーケティング部", "企画部"]
→ 営業部、マーケティング部、企画部のいずれかに所属するユーザーがアクセス可能
→ 経理部、総務部など、設定していない部署に所属するユーザーはアクセス不可
```

### ケース3: 高レベルユーザーのアクセス制御
```
条件: システムレベル >= 4
→ システムレベル4以上のユーザーがアクセス可能
→ システムレベル3以下のユーザーはアクセス不可
```

### ケース4: 職位による階層的アクセス制御
```
条件: 職位 >= 課長
→ 課長以上の職位のユーザーがアクセス可能
→ 担当、社員などの課長未満の職位のユーザーはアクセス不可
```

### ケース5: 職位範囲でのアクセス制御
```
条件: 職位 <= 担当
→ 担当以下の職位のユーザーがアクセス可能
→ 課長、部長などの担当より上位の職位のユーザーはアクセス不可
```

### ケース6: 複合条件のアクセス制御
```
条件: 
- 論理結合: AND
- 条件1: 部署 含む ["営業部"]
- 条件2: システムレベル >= 3
- 条件3: 職位 >= 課長
→ 営業部に所属し、システムレベル3以上で、課長以上の職位のユーザーがアクセス可能
→ 上記条件のいずれかを満たさないユーザーはアクセス不可
```

## 実装の詳細

### データ構造

#### ユーザー属性のデータ型
```typescript
interface UserAttributes {
  department_id: number | number[];  // 部署ID（単一または複数）
  position_id: number | number[];    // 職位ID（単一または複数）
  system_level: number;              // システムレベル（数値）
  roles: number[];                   // 役割ID（配列）
  user_id: number;                   // ユーザーID（数値）
  created_by: number;                // 作成者ID（数値）
}
```

### 演算子の実装

#### 等しい (eq) の実装
```typescript
function evaluateEqual(value: any, target: any): boolean {
  if (Array.isArray(target)) {
    // 条件値が配列の場合: ユーザー属性が配列内のいずれかの値に含まれるかチェック
    if (Array.isArray(value)) {
      return value.some(v => target.includes(v));
    } else {
      return target.includes(value);
    }
  } else {
    // 条件値が単一値の場合: 完全一致
    return value === target;
  }
}
```

#### 以上 (gte) の実装
```typescript
function evaluateGreaterThanOrEqual(value: number, target: number): boolean {
  return value >= target;
}
```

#### 以下 (lte) の実装
```typescript
function evaluateLessThanOrEqual(value: number, target: number): boolean {
  return value <= target;
}
```

### 条件評価の実装

#### 単一条件の評価
```typescript
function evaluateCondition(condition: Condition, userAttributes: UserAttributes): boolean {
  const value = userAttributes[condition.field];
  const target = condition.value;
  
  switch (condition.operator) {
    case 'eq':
      return evaluateEqual(value, target);
    case 'gte':
      return evaluateGreaterThanOrEqual(value, target);
    case 'lte':
      return evaluateLessThanOrEqual(value, target);
    default:
      return false;
  }
}
```

#### 複数条件の評価
```typescript
function evaluateConditions(conditions: Condition[], userAttributes: UserAttributes, operator: 'and' | 'or'): boolean {
  if (operator === 'and') {
    return conditions.every(condition => evaluateCondition(condition, userAttributes));
  } else {
    return conditions.some(condition => evaluateCondition(condition, userAttributes));
  }
}
```

## UI設計

### 条件ビルダーの構成

#### 基本要素
- **フィールド選択**: ユーザー属性の選択
- **演算子選択**: 等しい、以上、以下の選択
- **値入力**: 単一値または複数値の入力
- **論理結合**: AND/ORの選択

#### 複数条件の設定
- **条件の追加**: 新しい条件の追加
- **グループの追加**: ネストした条件グループの追加
- **条件の削除**: 不要な条件の削除

### 値入力の方法

#### 演算子に応じた入力形式の自動切り替え

**含む (in) の場合**
- 入力形式: チェックボックス（複数選択可能）
- 理由: 複数の値を選択して配列形式で設定

**以上 (gte) / 以下 (lte) の場合**
- 入力形式: ドロップダウン（単一選択）
- 理由: 階層的な比較のため、基準となる値を1つ選択

#### フィールド別の入力形式

**部署 (user.department_id)**
```
演算子: 含む (in)
入力形式: チェックボックス（複数選択）
例: ["営業部", "マーケティング部", "企画部"]
```

**職位 (user.position_id)**
```
演算子: 含む (in)
入力形式: チェックボックス（複数選択）
例: ["社員", "担当", "課長"]

演算子: 以上 / 以下
入力形式: ドロップダウン（単一選択）
例: "課長"（課長以上の職位）
```

**システムレベル (user.system_level)**
```
演算子: 含む (in)
入力形式: チェックボックス（複数選択）
例: ["レベル3", "レベル4", "レベル5"]

演算子: 以上 / 以下
入力形式: ドロップダウン（単一選択）
例: "レベル3"（レベル3以上のシステムレベル）
```

**役割 (user.roles)**
```
演算子: 含む (in)
入力形式: チェックボックス（複数選択）
例: ["営業マネージャー", "営業担当", "営業アシスタント"]
```

**ユーザーID (user.id)**
```
演算子: 含む (in)
入力形式: チェックボックス（複数選択）
例: ["1001", "1002", "1003"]
```

**作成者 (data.created_by)**
```
演算子: 含む (in)
入力形式: チェックボックス（複数選択）
例: ["1001", "1002", "1003"]
```

## 注意事項

### データ型の考慮

#### 配列と単一値の扱い
- ユーザー属性が配列の場合: いずれかの値に含まれるかチェック
- ユーザー属性が単一値の場合: 完全一致でチェック
- 条件値が配列の場合: ユーザー属性が配列内のいずれかの値に含まれるかチェック

#### 数値の比較
- システムレベル、金額などは数値として比較
- 文字列として比較しないよう注意

#### 階層的な比較
- 職位の「以上」「以下」: 職位テーブルの優先順位（priority）フィールドを使用
- システムレベルの「以上」「以下」: システムレベルテーブルの優先順位（priority）フィールドを使用
- 優先順位フィールドが存在しない場合は、IDの数値比較にフォールバック

### フィールド別演算子の制限

#### 演算子の適用ルール
- 各フィールドは使用可能な演算子が制限される
- フィールドに適さない演算子は選択肢に表示されない
- 演算子に応じて入力形式が自動的に切り替わる

#### データベース設計の前提
- 職位テーブル: `priority` または `sort_order` フィールドが必要
- システムレベルテーブル: `priority` または `sort_order` フィールドが必要
- これらのフィールドが存在しない場合は、階層的な比較ができない

### パフォーマンスの考慮

#### インデックスの活用
- 頻繁に使用される属性にはインデックスを設定
- 複合条件の場合は複合インデックスを検討

#### キャッシュの活用
- ユーザー属性の変更頻度が低い場合はキャッシュを活用
- 条件評価結果のキャッシュも検討

## 今後の拡張

### 新しい演算子の追加

#### 範囲指定演算子
```
between: 範囲指定（例: システムレベル between 3 and 5）
```

#### 文字列演算子
```
contains: 文字列の部分一致
startsWith: 文字列の前方一致
endsWith: 文字列の後方一致
```

### 新しい属性の追加

#### 時間属性
```
login_time: ログイン時間
last_access: 最終アクセス時間
```

#### 地理的属性
```
location: アクセス元の場所
ip_address: IPアドレス
```

## まとめ

ユーザー属性の設定方法は、以下の原則に基づいて設計されています：

1. **簡潔性**: 必要最小限の演算子で柔軟な条件設定を実現
2. **一貫性**: すべての条件が同じ形式で設定可能
3. **拡張性**: 新しい属性や演算子の追加が容易
4. **保守性**: コードが簡潔で理解しやすい

これらの原則により、複雑なアクセス制御要件に対応しながら、設定の簡潔性と保守性を両立しています。
